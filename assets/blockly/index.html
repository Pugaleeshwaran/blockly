<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover" />
  <title>rndmfg â€” Blockly (Python generator)</title>

  <!-- Icons (unchanged) -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.1/css/brands.min.css"
    crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.1/css/all.min.css"
    crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Work+Sans:ital,wght@0,100..900;1,100..900&display=swap"
    rel="stylesheet">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Playwrite+NO:wght@100..400&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="assets/blockly/style.css">
  <!-- Load Blockly once -->
  <script>
    (function loadBlockly() {
      function add(src, next) {
        var s = document.createElement('script');
        s.src = src; s.defer = false; s.async = false; s.onload = next || null;
        document.head.appendChild(s);
      }
      add('https://unpkg.com/blockly@10.4.3/blockly_compressed.js', function () {
        add('https://unpkg.com/blockly@10.4.3/blocks_compressed.js', function () {
          add('https://unpkg.com/blockly@10.4.3/python_compressed.js', function () {
            window.__blocklyLoaded = true;
          });
        });
      });
    })();
  </script>

</head>

<body>
  <div class="app">
    <!-- Top bar -->
    <div class="topbar">
      <div class="brand" style="display:flex;align-items:center;gap:10px">
        <img src="./assets/blockly/logo.png" alt="weblogo" style="width:60px; height:auto; object-fit:contain;">
        <div style="font-size:24px;font-weight:900;text-transform:uppercase">rndmfg</div>
      </div>
      <div class="btns">
        <!-- New: Connect Board button (for USB on desktop) -->
        <button class="btn-circle back" id="btnConnect" title="Connect Board">
          <i class="fa-solid fa-plug"></i>
        </button>
        <button class="btn-circle play" id="btnRun" title="Run â–¶"><i class="fa-solid fa-copy"></i></button>
        <button class="btn-circle save" id="btnSave" title="Save"><i class="fa-solid fa-download"></i></button>
        <button class="btn-circle fwd" id="btnLoad" title="Load"><i class="fa-brands fa-openid"></i></button>
        <button class="btn-circle back" id="btnClear" title="Clear"><i class="fa-solid fa-broom"></i></button>
      </div>
    </div>

    <!-- Left rail -->
    <aside class="rail">
      <div class="pill" style="background:#d9f4fb">Motion</div>
      <div class="pill" style="background:#ffd8d1">Ideas</div>
      <div class="pill" style="background:#fff2b9">Search</div>
      <div class="pill" style="background:#e4dcff">Brain</div>
    </aside>

    <!-- Main -->
    <section class="main">
      <div class="workspace">
        <div id="blocklyDiv"></div>
      </div>
      <div class="code">
        <header style="display:flex;justify-content:space-between;align-items:center">
          <strong>Python (generated)</strong><small id="status">ready</small>
        </header>
        <pre id="pyOut"># drag & drop blocks to generate Pythonâ€¦</pre>
      </div>
    </section>
  </div>

  <!-- Toolbox -->
  <xml id="toolbox" style="display:none">
    <category name="Digital in" colour="#FFD46B">
      <block type="port_on"></block>
      <block type="port_off"></block>
      <block type="sen_ultrasonic"></block>
      <block type="sen_temp"></block>
    </category>
    <category name="Digitalout" colour="#81d4ed">
      <block type="do_onoff"></block>
      <block type="do_dc_motor"></block>
      <block type="do_servo"></block>
      <block type="do_led"></block>
      <block type="bt_send"></block>
    </category>
    <category name="Delay" colour="#92e08d">
      <block type="ctl_delay"></block>
      <block type="do_led_param"></block>

    </category>
    <category name="Loop" colour="#FF6347">
      <block type="lp_while"></block>
      <block type="lp_break"></block>
      <block type="lp_repeat_count"></block>
      <block type="lp_label"></block>
    </category>
    <category name="Digitalin" colour="#FFB56A">
      <block type="din_if_else"></block>
      <block type="din_ir"></block>
      <block type="din_sound"></block>
      <block type="din_metal"></block>
      <block type="din_read"></block>
    </category>
    <sep></sep>
    <category name="Logic" colour="#4C97FF">
      <block type="logic_compare"></block>
      <block type="logic_operation"></block>
      <block type="logic_boolean"></block>
    </category>
    <category name="Maths" colour="#9ACD32">
      <block type="math_number">
        <field name="NUM">1</field>
      </block>
    </category>
    <category name="Function" custom="PROCEDURE" colour="#FF1493"></category>
    <category name="Variable" custom="VARIABLE" colour="#0000FF"></category>
  </xml>

  <!-- Port selection modal -->
  <div id="portSelectionModal">
    <div class="box">
      <h3>Select Port(s)</h3>
      <div class="box1">
        <div class="row"><label><input type="checkbox" id="port2"> P2</label></div>
        <div class="row"><label><input type="checkbox" id="port3"> P3</label></div>
        <div class="row"><label><input type="checkbox" id="port4"> P4</label></div>
        <div class="row"><label><input type="checkbox" id="port5"> P5</label></div>
        <div class="row"><label><input type="checkbox" id="port6"> P6</label></div>
        <div class="row"><label><input type="checkbox" id="port7"> P7</label></div>
        <div class="row"><label><input type="checkbox" id="port8"> P8</label></div>
        <div class="row"><label><input type="checkbox" id="port9"> P9</label></div>
      </div>
      <div class="box2">
        <div class="row"><label><input type="checkbox" id="port10"> P10</label></div>
        <div class="row"><label><input type="checkbox" id="port11"> P11</label></div>
        <div class="row"><label><input type="checkbox" id="port12"> P12</label></div>
        <div class="row"><label><input type="checkbox" id="port13"> P13</label></div>
        <div class="row"><label><input type="checkbox" id="port14"> P14</label></div>
        <div class="row"><label><input type="checkbox" id="port15"> P15</label></div>
        <div class="row"><label><input type="checkbox" id="port16"> P16</label></div>
      </div>
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">
        <button onclick="savePortSelection()">Save</button>
        <button onclick="closePortModal()">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Motor selection modal -->
  <div id="motorSelectionModal" style="display:none;">
    <div class="box">
      <h3>Select Motor(s)</h3>
      <div class="box1">
        <div class="row"><label><input type="checkbox" id="motorM1"> M1</label></div>
        <div class="row"><label><input type="checkbox" id="motorM2"> M2</label></div>
        <div class="row"><label><input type="checkbox" id="motorM3"> M3</label></div>
        <div class="row"><label><input type="checkbox" id="motorM4"> M4</label></div>
      </div>
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">
        <button onclick="saveMotorSelection()">Save</button>
        <button onclick="closeModal()">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Servo selection modal -->
  <div id="servoSelectionModal" style="display:none;">
    <div class="servo-box">
      <h3>Select Servo Port</h3>

      <div class="servo-list">
        <label class="servo-row">
          <input type="radio" name="servoPort" value="C8">
          <div class="servo-name">Servo S1</div>
          <div class="servo-pins">
            <span class="pin pin-gnd">GND</span>
            <span class="pin pin-vcc">VCC</span>
            <span class="pin pin-sig">SIG</span>
          </div>
        </label>

        <label class="servo-row">
          <input type="radio" name="servoPort" value="S2">
          <div class="servo-name">Servo S2</div>
          <div class="servo-pins">
            <span class="pin pin-gnd">GND</span>
            <span class="pin pin-vcc">VCC</span>
            <span class="pin pin-sig">SIG</span>
          </div>
        </label>

        <label class="servo-row">
          <input type="radio" name="servoPort" value="S3">
          <div class="servo-name">Servo S3</div>
          <div class="servo-pins">
            <span class="pin pin-gnd">GND</span>
            <span class="pin pin-vcc">VCC</span>
            <span class="pin pin-sig">SIG</span>
          </div>
        </label>

        <label class="servo-row">
          <input type="radio" name="servoPort" value="S4">
          <div class="servo-name">Servo S4</div>
          <div class="servo-pins">
            <span class="pin pin-gnd">GND</span>
            <span class="pin pin-vcc">VCC</span>
            <span class="pin pin-sig">SIG</span>
          </div>
        </label>
      </div>

      <div class="servo-actions">
        <button type="button" onclick="saveServoSelection()">Save</button>
        <button type="button" onclick="closeServoModal()">Cancel</button>
      </div>
    </div>
  </div>
  <!-- LED pin selection modal -->
  <div id="ledPinSelectionModal">
    <div class="box">
      <h3>Select LED Pin(s)</h3>

      <div class="box1">
        <div class="row"><label><input type="checkbox" id="ledPinD2"> D2</label></div>
        <div class="row"><label><input type="checkbox" id="ledPinD3"> D3</label></div>
        <div class="row"><label><input type="checkbox" id="ledPinD4"> D4</label></div>
        <div class="row"><label><input type="checkbox" id="ledPinD5"> D5</label></div>
        <div class="row"><label><input type="checkbox" id="ledPinG0"> G0</label></div>
        <div class="row"><label><input type="checkbox" id="ledPinD7"> D7</label></div>
        <div class="row"><label><input type="checkbox" id="ledPinD8"> D8</label></div>
        <div class="row"><label><input type="checkbox" id="ledPinD9"> D9</label></div>
      </div>

      <div class="savebtn" style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">
        <button type="button" onclick="saveLedPinSelection()">Save</button>
        <button type="button" onclick="closeLedPinModal()">Cancel</button>
      </div>
    </div>
  </div>
<script>   
    /* --- wait for Blockly --- */
    async function waitForBlockly(timeoutMs = 5000) {
      const t0 = Date.now();
      while (!(window.__blocklyLoaded && window.Blockly && Blockly.Python)) {
        await new Promise(r => setTimeout(r, 50));
        if (Date.now() - t0 > timeoutMs) break;
      }
      return !!(window.__blocklyLoaded && window.Blockly && Blockly.Python);
    }

    /* --- define blocks (including modal-driven blocks) --- */
    function defineBlocks() {
      Blockly.defineBlocksWithJsonArray([
        {
          type: "start",
          message0: "Start",
          style: "start_block",
          output: null,
          nextStatement: null
        },
        {
          type: "port_on",
          message0: "DigitalOut ON %1 %2",
          args0: [
            {
              type: "field_image",
              src: "./assets/img/Chips_Chips_Show.png",
              width: 15,
              height: 15,
              alt: "",
              name: "IMG"
            },
            {
              type: "field_label",
              name: "PORTS",
              text: ""
            }
          ],
          style: "control_blocks",
          previousStatement: null,
          nextStatement: null,
          extensions: ["port_on_img_click", "port_border_class"]
        },
        {
          type: "port_off",
          message0: "DigitalOut OFF %1 %2",
          args0: [
            {
              type: "field_image",
              src: "./assets/img/Chips_Chips_Show.png",
              width: 15,
              height: 15,
              alt: "",
              name: "IMG"
            },
            {
              type: "field_label",
              name: "PORTS",
              text: ""
            }
          ],
          colour: "#ffb56a",
          previousStatement: null,
          nextStatement: null,
          extensions: ["port_image_click"]
        },
        {
          type: "sen_ultrasonic",
          message0: "ultrasonic distance on port %1",
          args0: [
            {
              type: "field_number",
              name: "PORT",
              value: 2,
              min: 0,
              max: 99
            }
          ],
          style: "control_blocks",
          previousStatement: null,
          nextStatement: null
          // remove: output: "Number"
        }
        ,
        {
          type: "sen_temp",
          message0: "temperature on port %1",
          args0: [
            {
              type: "field_number",
              name: "PORT",
              value: 3,
              min: 0,
              max: 99
            }
          ],
          style: "control_blocks",
          previousStatement: null,
          nextStatement: null
        },


        {
          type: "do_onoff",
          message0: "digital write pins %1 %2 %3",
          args0: [
            {
              type: "field_image",
              src: "./assets/img/Chips_Chips_Show.png",
              width: 15,
              height: 15,
              alt: "",
              name: "IMG"
            },
            {
              type: "field_label",
              name: "PORTS",
              text: ""
            },
            {
              type: "field_dropdown",
              name: "STATE",
              options: [
                ["ON", "1"],
                ["OFF", "0"]
              ]
            }
          ],
          colour: "#81d4ed",
          previousStatement: null,
          nextStatement: null,
          extensions: ["port_image_click", "doonoff_border_class"]
        },
        {
          type: "do_dc_motor",
          message0: "DC Motor %1 %2 %3 %4",
          args0: [
            {
              type: "field_image",
              src: "./assets/img/Chips_Chips_Show.png",
              width: 15,
              height: 15,
              alt: "",
              name: "IMG"
            },
            {
              type: "field_label",
              name: "MOTORS",
              text: ""
            },
            {
              type: "field_number",
              name: "SPEED",
              value: 60,
              min: -100,
              max: 100,
              precision: 1
            },
            {
              type: "field_label",
              text: "%"
            }
          ],
          colour: "#81d4ed",
          previousStatement: null,
          nextStatement: null,
          extensions: ["motor_image_click"]
        },
        {
          type: "do_servo",
          message0: "servo on %1 %2 %3 speed %4",
          args0: [
            {
              type: "field_image",
              src: "./assets/img/Chips_Chips_Show.png",
              width: 15,
              height: 15,
              alt: "",
              name: "IMG"
            },
            {
              type: "field_label",
              name: "SERVO_PORT",
              text: ""
            },
            {
              type: "field_number",
              name: "ANG",
              value: 90,
              min: 0,
              max: 180,
              precision: 1
            },
            {
              type: "field_number",
              name: "SPEED",
              value: 50, // Default speed value (you can adjust it)
              min: 0,
              max: 100,
              precision: 1
            }
          ],
          colour: "#81d4ed",
          previousStatement: null,
          nextStatement: null,
          extensions: ["servo_image_click", "servo_border_class"]
        }

        ,
        {
          type: "bt_send",
          message0: "Bluetooth send %1",
          args0: [
            {
              type: "input_value",
              name: "TEXT"
            }
          ],
          previousStatement: null,
          nextStatement: null,
          style: "control_blocks"
        },

        {
          type: "do_led",
          message0: "LED %1 %2 %3",
          args0: [
            {
              type: "field_image",
              src: "./assets/img/Chips_Chips_Show.png",
              width: 15,
              height: 15,
              alt: "",
              name: "IMG"
            },
            {
              type: "field_label",
              name: "PORTS",
              text: ""
            },
            {
              type: "field_dropdown",
              name: "STATE",
              options: [
                ["ON", "1"],
                ["OFF", "0"]
              ]
            }
          ],
          colour: "#81d4ed",
          previousStatement: null,
          nextStatement: null,
          extensions: ["port_image_click", "doonoff_border_class"]
        },
        {
          type: "ctl_delay",
          message0: "delay %1 ms",
          args0: [{
            type: "field_number",
            name: "MS",
            value: 500,
            min: 0,
            max: 600000
          }],
          style: "led_blocks",
          previousStatement: null,
          nextStatement: null
        },
        {
          type: "lp_while",
          message0: "while %1",
          args0: [{ type: "input_value", name: "COND", check: "Boolean" }],
          message1: "do %1",
          args1: [{ type: "input_statement", name: "DO" }],
          style: "start_block",
          previousStatement: null,
          nextStatement: null,
          extensions: ["while_border_class"]
        },
        {
          type: "lp_break",
          message0: "break",
          style: "start_block",
          previousStatement: null,
          nextStatement: null
        },
        {
          type: "lp_repeat_count",
          message0: "repeat %1 times",
          args0: [{
            type: "field_number",
            name: "COUNT", value: 4, min: 0, max: 100000
          }],
          message1: "do %1",
          args1: [{
            type: "input_statement",
            name: "DO"
          }],
          style: "start_block",
          previousStatement: null,
          nextStatement: null
        },
        {
          type: "lp_label",
          message0: "label %1",
          args0: [{
            type: "field_input",
            name: "NAME",
            text: "lbl1"
          }],
          style: 'start_block',
          previousStatement: null,
          nextStatement: null
        },
        {
          type: "din_if_else",
          message0: "if %1",
          args0: [{ type: "input_value", name: "COND", check: "Boolean" }],
          message1: "do %1",
          args1: [{ type: "input_statement", name: "DO" }],
          message2: "else %1",
          args2: [{ type: "input_statement", name: "ELSE" }],
          style: "control_blocks",
          previousStatement: null,
          nextStatement: null,
          extensions: ["ifelse_border_class"]
        },
        {
          type: "din_ir",
          message0: "IR sensor pin %1",
          args0: [{
            type: "field_number",
            name: "PIN", value: 4, min: 0, max: 99
          }],
          style: "control_blocks",
          output: "Boolean"
        },
        {
          type: "din_sound",
          message0: "Sound sensor pin %1",
          args0: [{
            type: "field_number",
            name: "PIN",
            value: 5, min: 0,
            max: 99
          }],
          style: "control_blocks",
          output: "Boolean"
        },
        {
          type: "din_metal",
          message0: "Metal sensor pin %1",
          args0: [{
            type: "field_number",
            name: "PIN",
            value: 6,
            min: 0,
            max: 99
          }],
          style: "control_blocks",
          output: "Boolean"
        },
        {
          type: "din_read",
          message0: "digital read pin %1",
          args0: [{
            type: "field_number",
            name: "PIN",
            value: 7,
            min: 0,
            max: 99
          }],
          style: "control_blocks",
          output: "Boolean"
        },
        {
          type: "do_led_param",
          message0: "LED write %1 %2 value %3 time %4",
          args0: [
            {
              type: "field_image",
              src: "./assets/img/Chips_Chips_Show.png",
              width: 15,
              height: 15,
              alt: "",
              name: "IMG"
            },
            {
              type: "field_label",
              name: "PORTS",   // keep PORTS here
              text: ""
            },
            {
              type: "input_value",
              name: "VAL"
            },
            {
              type: "input_value",
              name: "VAL2"
            }
          ],
          colour: "#81d4ed",
          previousStatement: null,
          nextStatement: null,
          extensions: ["led_pin_image_click", "doonoff_border_class"]
        }



      ]);

      Blockly.Extensions.register('port_on_img_click', function () {
        const imgField = this.getField('IMG');
        if (!imgField) return;
        imgField.setOnClickHandler(() => {
          openPortSelectionModal(this);
        });
      });

      Blockly.Extensions.register('port_image_click', function () {
        const imgField = this.getField('IMG');
        if (!imgField) return;
        imgField.setOnClickHandler(() => {
          openPortSelectionModal(this);
        });
      });

      Blockly.Extensions.register('motor_image_click', function () {
        const imgField = this.getField('IMG');
        imgField.setOnClickHandler(() => {
          openMotorSelectionModal(this);
        });
      });

      Blockly.Extensions.register('servo_image_click', function () {
        const imgField = this.getField('IMG');
        if (!imgField) return;
        imgField.setOnClickHandler(() => {
          openServoSelectionModal(this);
        });
      });

      /* ===== BORDER / TYPE CLASS EXTENSIONS (for gradients) ===== */
      Blockly.Extensions.register('while_border_class', function () {
        const block = this;
        block.setOnChange(function () {
          if (block.svgGroup_) {
            block.svgGroup_.classList.add('block-while');
            applyStrokeAndShadowToBlock(block);
          }
        });
      });

      Blockly.Extensions.register('ifelse_border_class', function () {
        const block = this;
        block.setOnChange(function () {
          if (block.svgGroup_) {
            block.svgGroup_.classList.add('block-ifelse');
          }
        });
      });

      Blockly.Extensions.register('doonoff_border_class', function () {
        const block = this;
        block.setOnChange(function () {
          if (block.svgGroup_) {
            block.svgGroup_.classList.add('block-doonoff');
          }
        });
      });
      Blockly.Extensions.register('port_border_class', function () {
        const block = this;
        block.setOnChange(function () {
          if (block.svgGroup_) {
            block.svgGroup_.classList.add('block-porton')
          }
        })
      })
      Blockly.Extensions.register('servo_border_class', function () {
        const block = this;
        block.setOnChange(function () {
          if (block.svgGroup_) {
            block.svgGroup_.classList.add('block-servo');
          }
        });
      });
      Blockly.Extensions.register('led_pin_image_click', function () {
        const imgField = this.getField('IMG');
        if (!imgField) return;
        imgField.setOnClickHandler(() => {
          openLedPinSelectionModal(this);
        });
      });



    }

    /* --- generators --- */
    function defineGenerators() {
      const py = Blockly.Python;
      Blockly.Python['do_led'] = function (block) {
        const portsTxt = block.getFieldValue('PORTS') || '';
        const stateVal = block.getFieldValue('STATE') || '0';

        const ports = portsTxt
          .split(',')
          .map(s => s.trim())
          .filter(Boolean);

        if (!ports.length) {
          return "# do_led: no ports selected\n";
        }

        const fn = (stateVal === '1') ? 'robot.led_on' : 'robot.led_off';

        return ports.map(p => `${fn}(${p})\n`).join('');
      };
      Blockly.Python['bt_send'] = function (block) {
        const txt = Blockly.Python.valueToCode(block, 'TEXT', Blockly.Python.ORDER_NONE) || "''";
        // Example: send text over Bluetooth
        return `robot.bt_send(${txt})\n`;
      };
      Blockly.Python['sen_ultrasonic'] = function (block) {
        const port = block.getFieldValue('PORT') || 0;
        // Statement style: maybe store or print the distance
        return `distance = robot.ultrasonic_cm(${port})\n`;
      };

      Blockly.Python['sen_temp'] = function (block) {
        const port = block.getFieldValue('PORT') || 0;
        // example: store temperature into a global variable "temperature"
        return `temperature = robot.temperature_c(${port})\n`;
      };


      Blockly.Python['do_onoff'] = function (block) {
        const portsTxt = block.getFieldValue('PORTS') || '';
        const stateVal = block.getFieldValue('STATE') || '0';

        const ports = portsTxt
          .split(',')
          .map(s => s.trim())
          .filter(Boolean);

        if (!ports.length) {
          return "# do_onoff: no ports selected\n";
        }

        const fn = (stateVal === '1') ? 'robot.port_on' : 'robot.port_off';
        return ports.map(p => `${fn}(${p})\n`).join('');
      };

      Blockly.Python['port_on'] = function (block) {
        var ports = block.getFieldValue('PORTS');
        var portList = ports.split(',').map(s => s.trim());
        var code = '';
        portList.forEach(function (port) {
          code += `\n robot.port_on(${port})\n`;
        });
        return code;
      };

      Blockly.Python['port_off'] = function (block) {
        var ports = block.getFieldValue('PORTS');
        var portList = ports.split(',').map(s => s.trim());
        var code = '';
        portList.forEach(function (port) {
          code += `\n robot.port_off(${port})\n`;
        });
        return code;
      };

      Blockly.Python['do_dc_motor'] = function (block) {
        const speed = block.getFieldValue('SPEED') || 0;
        const motors = (block.getFieldValue('MOTORS') || '').split(',').map(s => s.trim()).filter(Boolean);

        if (motors.length === 0) {
          return "# No motors selected\n";
        }

        let code = "";
        motors.forEach(motor => {
          code += `\n robot.dc_motor("${motor}", ${speed})\n`;
        });

        return code;
      };

      py['start'] = () => 'start()\ndef start():';

      Blockly.Python['do_servo'] = function (block) {
        const servoPort = block.getFieldValue('SERVO_PORT') || '';
        const angle = block.getFieldValue('ANG') || 90;
        const speed = block.getFieldValue('SPEED') || 50; // Get the speed value

        if (!servoPort) {
          return "# do_servo: no servo port selected\n";
        }

        // Include speed in the generated code
        return `\n  servo_port('${servoPort}', ${angle}, ${speed})\n`;
      };


      Blockly.Python['ctl_delay'] = function (block) {
        const ms = block.getFieldValue('MS') || 0;
        return `\n  robot.delay_ms(${ms})\n`;
      };

      py['lp_while'] = b => {
        const cond = py.valueToCode(b, 'COND', py.ORDER_NONE) || 'False';
        const body = py.statementToCode(b, 'DO') || '  pass\n';
        return `\n  while ${cond}:\n${body}`;
      };

      py['lp_break'] = () => 'break\n';

      py['lp_repeat_count'] = b => {
        const n = +b.getFieldValue('COUNT') || 0;
        const body = py.statementToCode(b, 'DO') || '  pass\n';
        return `\n  for _ in range(${n}):\n${body}`;
      };

      py['lp_label'] = b => `# label: ${b.getFieldValue('NAME') || 'lbl1'}\n`;

      py['din_if_else'] = b => {
        const cond = py.valueToCode(b, 'COND', py.ORDER_NONE) || 'False';
        const do_ = py.statementToCode(b, 'DO') || '  pass\n';
        const el_ = py.statementToCode(b, 'ELSE') || '  pass\n';
        return `\n  if ${cond}:\n${do_}else:\n${el_}`;
      };
      Blockly.Python['do_led_param'] = function (block) {
        const pinsTxt = block.getFieldValue('PORTS') || '';   // ðŸ”´ PINS â†’ PORTS

        const valueCode1 =
          Blockly.Python.valueToCode(block, 'VAL', Blockly.Python.ORDER_NONE) || '0';

        const valueCode2 =
          Blockly.Python.valueToCode(block, 'VAL2', Blockly.Python.ORDER_NONE) || '0';

        const pins = pinsTxt
          .split(',')
          .map(s => s.trim())
          .filter(Boolean);

        if (!pins.length) {
          return "# do_led_param: no pins selected\n";
        }

        let code = '';
        pins.forEach(pin => {
          // using 'D3' style names:
          code += `\n led_blink('${pin}', ${valueCode1}, ${valueCode2})\n`;
        });

        return code;
      };





      py['din_ir'] = b => [`robot.ir_detected(${b.getFieldValue('PIN')})`, py.ORDER_ATOMIC];
      py['din_sound'] = b => [`robot.sound_detected(${b.getFieldValue('PIN')})`, py.ORDER_ATOMIC];
      py['din_metal'] = b => [`robot.metal_detected(${b.getFieldValue('PIN')})`, py.ORDER_ATOMIC];
      py['din_read'] = b => [`bool(robot.digital_read(${b.getFieldValue('PIN')}))`, py.ORDER_ATOMIC];
    }

    /* --- modal wiring --- */
    let currentPortBlock = null;
    const ALL_PORT_NUMBERS = [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16];

    function openPortSelectionModal(block) {
      currentPortBlock = block;
      const txt = block.getFieldValue('PORTS') || '';
      const selectedSet = new Set(
        txt.split(',').map(s => s.trim()).filter(Boolean)
      );

      ALL_PORT_NUMBERS.forEach(p => {
        const cb = document.getElementById('port' + p);
        if (cb) cb.checked = selectedSet.has(String(p));
      });

      document.getElementById('portSelectionModal').style.display = 'block';
    }

    function closePortModal() {
      document.getElementById('portSelectionModal').style.display = 'none';
      currentPortBlock = null;
    }

    function savePortSelection() {
      if (!currentPortBlock) { closePortModal(); return; }

      const sel = [];
      ALL_PORT_NUMBERS.forEach(p => {
        const cb = document.getElementById('port' + p);
        if (cb && cb.checked) sel.push(String(p));
      });

      const label = sel.length ? sel.join(',') : 'â€”';
      currentPortBlock.setFieldValue(label, 'PORTS');

      closePortModal();
    }

    let currentMotorBlock = null;

    function openMotorSelectionModal(block) {
      currentMotorBlock = block;
      const selectedMotors = new Set((block.getFieldValue('MOTORS') || '').split(',').map(s => s.trim()));

      ['M1', 'M2', 'M3', 'M4'].forEach(motor => {
        const checkbox = document.getElementById('motor' + motor);
        if (checkbox) checkbox.checked = selectedMotors.has(motor);
      });

      document.getElementById('motorSelectionModal').style.display = 'block';
    }

    function closeModal() {
      document.getElementById('motorSelectionModal').style.display = 'none';
    }

    function saveMotorSelection() {
      if (!currentMotorBlock) { closeModal(); return; }

      const selected = [];
      ['M1', 'M2', 'M3', 'M4'].forEach(motor => {
        const checkbox = document.getElementById('motor' + motor);
        if (checkbox && checkbox.checked) selected.push(motor);
      });

      const label = selected.length ? selected.join(',') : 'â€”';
      currentMotorBlock.setFieldValue(label, 'MOTORS');

      closeModal();
    }

    /* ==== SERVO MODAL ==== */
    let currentServoBlock = null;

    function openServoSelectionModal(block) {
      currentServoBlock = block;
      const currentPort = block.getFieldValue('SERVO_PORT') || '';

      const radios = document.querySelectorAll('#servoSelectionModal input[name="servoPort"]');
      radios.forEach(r => {
        r.checked = (r.value === currentPort);
      });

      document.getElementById('servoSelectionModal').style.display = 'block';
    }

    function closeServoModal() {
      document.getElementById('servoSelectionModal').style.display = 'none';
      currentServoBlock = null;
    }

    function saveServoSelection() {
      if (!currentServoBlock) { closeServoModal(); return; }

      const radios = document.querySelectorAll('#servoSelectionModal input[name="servoPort"]');
      let selectedValue = '';
      radios.forEach(r => {
        if (r.checked) selectedValue = r.value;
      });

      if (!selectedValue) {
        alert('Please select a servo port.');
        return;
      }

      currentServoBlock.setFieldValue(selectedValue, 'SERVO_PORT');
      closeServoModal();
    }
    /* ==== LED PIN MODAL ==== */
    let currentLedBlock = null;
    const LED_PIN_NAMES = ['D2', 'D3', 'D4', 'D5', 'G0', 'D7', 'D8', 'D9'];

    function openLedPinSelectionModal(block) {
      currentLedBlock = block;

      const txt = block.getFieldValue('PORTS') || '';   // ðŸ”´ changed PINS â†’ PORTS
      const selected = new Set(
        txt.split(',').map(s => s.trim()).filter(Boolean)
      );

      LED_PIN_NAMES.forEach(pin => {
        const cb = document.getElementById('ledPin' + pin);
        if (cb) cb.checked = selected.has(pin);
      });

      document.getElementById('ledPinSelectionModal').style.display = 'block';
    }

    function closeLedPinModal() {
      document.getElementById('ledPinSelectionModal').style.display = 'none';
      currentLedBlock = null;
    }

    function saveLedPinSelection() {
      if (!currentLedBlock) {
        closeLedPinModal();
        return;
      }

      const sel = [];
      LED_PIN_NAMES.forEach(pin => {
        const cb = document.getElementById('ledPin' + pin);
        if (cb && cb.checked) sel.push(pin);
      });

      const label = sel.length ? sel.join(',') : 'â€”';
      currentLedBlock.setFieldValue(label, 'PORTS');   // ðŸ”´ changed PINS â†’ PORTS

      closeLedPinModal();
    }



    // ---- Add multiple gradient defs into Blockly SVG (from Code A) ----
    function addGradientDefs() {
      const svg = document.querySelector('svg.blocklySvg');

      if (!svg) {
        setTimeout(addGradientDefs, 50);  // Wait for Blockly to load if not found
        return;
      }

      let defs = svg.querySelector('defs');
      if (!defs) {
        defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
        svg.prepend(defs);
      }

      // Add gradient definitions
      function makeLinearGradient(id, stops) {
        const grad = document.createElementNS("http://www.w3.org/2000/svg", "linearGradient");
        grad.setAttribute('id', id);
        grad.setAttribute('x1', '0%');
        grad.setAttribute('y1', '0%');
        grad.setAttribute('x2', '0%');
        grad.setAttribute('y2', '100%');

        stops.forEach(s => {
          const stop = document.createElementNS("http://www.w3.org/2000/svg", "stop");
          stop.setAttribute('offset', s.offset);
          stop.setAttribute('stop-color', s.color);
          stop.setAttribute('stop-opacity', s.opacity);
          grad.appendChild(stop);
        });
        defs.appendChild(grad);
      }

      // Defining various gradient IDs
      makeLinearGradient('gradDefault', [
        { offset: '0%', color: '#BCD4FF', opacity: 1 },
        { offset: '50%', color: '#FED36B', opacity: 1 },
        { offset: '100%', color: '#F6A9BE', opacity: 1 }
      ]);

      makeLinearGradient('gradLoop', [
        { offset: '0%', color: '#facc15', opacity: 1 },
        { offset: '100%', color: '#fb923c', opacity: 1 }
      ]);

      makeLinearGradient('gradIfElse', [
        { offset: '0%', color: '#fb923c', opacity: 1 },
        { offset: '100%', color: '#f97316', opacity: 1 }
      ]);

      makeLinearGradient('gradDigital', [
        { offset: '0%', color: 'transparent', opacity: 1 },
        { offset: '50%', color: '#FFEDF3', opacity: 1 },
        { offset: '100%', color: 'transparent', opacity: 1 }
      ]);

      makeLinearGradient('gradServo', [
        { offset: '0%', color: '#a855f7', opacity: 1 },
        { offset: '100%', color: '#ec4899', opacity: 1 }
      ]);

      makeLinearGradient('gradPorton', [
        { offset: '0%', color: '#BCD4FF', opacity: 1 },
        { offset: '50%', color: '#FED36B', opacity: 1 },
        { offset: '100%', color: '#F6A9BE', opacity: 1 }
      ]);

      // Add filter for drop shadow effect
      function createDropShadowFilter(id, dx, dy, stdDeviation, color) {
        const filter = document.createElementNS("http://www.w3.org/2000/svg", "filter");
        filter.setAttribute('id', id);
        filter.setAttribute('x', '-50%');
        filter.setAttribute('y', '-50%');
        filter.setAttribute('width', '200%');
        filter.setAttribute('height', '200%');

        const feDropShadow = document.createElementNS("http://www.w3.org/2000/svg", "feDropShadow");
        feDropShadow.setAttribute('dx', dx);
        feDropShadow.setAttribute('dy', dy);
        feDropShadow.setAttribute('stdDeviation', stdDeviation);
        feDropShadow.setAttribute('flood-color', color);
        filter.appendChild(feDropShadow);

        defs.appendChild(filter);
      }
      // Add drop shadow filter
      createDropShadowFilter('dropShadow1', 2, 2, 3, '#000000');
      createDropShadowFilter('dropShadow2', 4, 4, 5, '#ff6347');
    }

    // Apply gradient, stroke, and shadow to a specific block
    function applyGradientAndShadowToBlock(block) {
      const blockPath = block.svgGroup_?.querySelector('.blocklyPath');

      if (!blockPath) return;

      // Apply gradient as the fill
      blockPath.setAttribute('fill', 'url(#gradDefault)');  // Default gradient, adjust as needed

      // Apply stroke (outline)
      blockPath.setAttribute('stroke', '#4b4b4b');  // Dark gray stroke color
      blockPath.setAttribute('stroke-width', '2');  // Stroke width

      // Apply drop shadow filter based on block type
      if (block.type === 'start') {
        blockPath.setAttribute('filter', 'url(#dropShadow1)');
      } else if (block.type === 'do_dc_motor') {
        blockPath.setAttribute('filter', 'url(#dropShadow2)');
      } else {
        blockPath.setAttribute('filter', 'url(#dropShadow1)');  // Default shadow
      }
    }

    // Define the applyStrokeAndShadowToBlock function
    function applyStrokeAndShadowToBlock(block) {
      const blockPath = block.svgGroup_?.querySelector('.blocklyPath');

      if (!blockPath) return;

      // Apply stroke (outline)
      blockPath.setAttribute('stroke', '#4b4b4b');  // Dark gray stroke color
      blockPath.setAttribute('stroke-width', '2');  // Stroke width
      blockPath.setAttribute('stroke-linejoin', 'round');  // Rounded corners for the stroke

      // Apply shadow (drop-shadow effect)
      blockPath.setAttribute('filter', 'url(#dropShadow1)'); // Assuming a drop shadow filter exists

      // Optionally, apply a paint order for stroke first, then fill
      blockPath.setAttribute('paint-order', 'stroke');
    }
    // Create drop shadow filter in SVG
    function createDropShadowFilter(id, dx, dy, stdDeviation, color) {
      const filter = document.createElementNS("http://www.w3.org/2000/svg", "filter");
      filter.setAttribute('id', id);
      filter.setAttribute('x', '-50%');
      filter.setAttribute('y', '-50%');
      filter.setAttribute('width', '200%');
      filter.setAttribute('height', '200%');

      const feDropShadow = document.createElementNS("http://www.w3.org/2000/svg", "feDropShadow");
      feDropShadow.setAttribute('dx', dx);
      feDropShadow.setAttribute('dy', dy);
      feDropShadow.setAttribute('stdDeviation', stdDeviation);
      feDropShadow.setAttribute('flood-color', color);
      filter.appendChild(feDropShadow);

      // Append to the defs element in SVG
      const defs = document.querySelector('svg.blocklySvg defs') || document.createElementNS("http://www.w3.org/2000/svg", "defs");
      defs.appendChild(filter);
    }

    // Call the function to create drop shadow filters
    createDropShadowFilter('dropShadow1', 2, 2, 3, '#000000');  // Example shadow
    createDropShadowFilter('dropShadow2', 4, 4, 5, '#ff6347');  // Example shadow



    function setupGradientAndShadowOnBlocks() {
      Blockly.getMainWorkspace().addChangeListener((e) => {
        if (e.type === Blockly.Events.BLOCK_CREATE || e.type === Blockly.Events.BLOCK_CHANGE) {
          applyToAllBlocks();
        }
      });
    }

    // Apply gradient and shadow to all blocks in the workspace
    function applyToAllBlocks() {
      const blocks = Blockly.getMainWorkspace().getAllBlocks();
      blocks.forEach(block => {
        applyGradientAndShadowToBlock(block);
      });
    }



    // Remove blue selection glow (from Code A)
    function killBlueSelection() {
      const style = document.createElement('style');
      style.textContent = `
        svg.blocklySvg .blocklySelected {
          filter: none !important;
        }
        svg.blocklySvg .blocklySelected > .blocklyPath {
          stroke: none !important;
          stroke-width: 0 !important;
        }
        svg.blocklySvg .blocklySelected > .blocklyPathLight {
          display: none !important;
        }
      `;
      document.head.appendChild(style);
    }
    // ===== Desktop: Web Serial USB to STM32 =====
    let stm32Port = null;
    let stm32Writer = null;

    // Ask user to choose the STM32 serial port and open it
    async function connectStm32() {
      if (!("serial" in navigator)) {
        alert("Web Serial not supported. Use Chrome or Edge on desktop.");
        return;
      }

      try {
        // User selects the board (USB CDC device)
        stm32Port = await navigator.serial.requestPort();
        await stm32Port.open({ baudRate: 115200 }); // must match your firmware

        const textEncoder = new TextEncoder();
        stm32Writer = stm32Port.writable.getWriter();

        alert("Connected to STM32 over USB!");
        console.log("STM32: serial port opened");
      } catch (e) {
        console.error("Failed to open serial port:", e);
        alert("Failed to connect to board.");
      }
    }

    // Build the protocol message for STM32
    function buildPycodeMessage(code, entry = "main") {
      const size = code.length;
      return `PYCODE\nENTRY:${entry}\nSIZE:${size}\n\n${code}`;
    }

    // Send Python code to STM32 over Web Serial
    // Send a simple REPL command (no PYCODE header, just plain text)
    async function sendCommandToStm32(cmd) {
      if (!stm32Port || !stm32Writer) {
        alert("Board not connected. Click 'Connect Board' first.");
        return;
      }

      try {
        // MicroPython REPL likes \r\n
        const payload = cmd + "\r\n";
        const data = new TextEncoder().encode(payload);
        await stm32Writer.write(data);
        console.log("Sent to STM32 CMD:", JSON.stringify(payload));
      } catch (e) {
        console.error("Error sending command to STM32:", e);
        alert("Failed to send command to STM32.");
      }
    }

    /* --- app start --- */
    async function start() {
      // Connect Board button (desktop Web Serial)
      document.getElementById("btnConnect").onclick = () => {
        connectStm32();
      };

      const ok = await waitForBlockly();
      if (!ok) { console.error('Blockly/Python failed to load'); return; }

      // Theme from Code A (glass style)
      const Theme = Blockly.Theme.defineTheme('rndmfg_glass', {
        base: Blockly.Themes.Classic,

        blockStyles: {
          start_block: {
            colourPrimary: '#BCD4FF',
            colourSecondary: '#FED36B',
            colourTertiary: '#F6A9BE'
          },
          control_blocks: {
            colourPrimary: '#000080',
            colourSecondary: '#f97316',
            colourTertiary: '#fed7aa'
          },
          led_blocks: {
            colourPrimary: '#880808',
            colourSecondary: '#22c55e',
            colourTertiary: '#bbf7d0'
          },
          move_blocks: {
            colourPrimary: '#880808',
            colourSecondary: '#7c3aed',
            colourTertiary: '#e9d5ff'
          }
        },

        categoryStyles: {
          digitalin_cat: { colour: '#fb923c' },
          digitalout_cat: { colour: '#38bdf8' },
          loop_cat: { colour: '#a855f7' },
          delay_cat: { colour: '#4ade80' },
          logic_cat: { colour: '#facc15' },
          math_cat: { colour: '#22c55e' }
        },

        componentStyles: {
          workspaceBackgroundColour: '#ffffff',
          toolboxBackgroundColour: 'rgba(15,23,42,0.7)',
          toolboxForegroundColour: '#e5e7eb',
          flyoutBackgroundColour: 'rgba(15,23,42,0.95)',
          flyoutForegroundColour: '#e5e7eb',
          flyoutOpacity: 1,
          insertionMarkerColour: '#38bdf8',
          insertionMarkerOpacity: 0.0,
          scrollbarColour: '#94a3b8',
          selectedGlowColour: 'transparent',
          selectedGlowOpacity: 0,
          selectedGlowSize: 1,
          cursorColour: '#facc15'
        }
      });

      defineBlocks();
      defineGenerators();

      const workspace = Blockly.inject('blocklyDiv', {
        toolbox: document.getElementById('toolbox'),
        theme: Theme,
        renderer: 'zelos',
        grid: { spacing: 30, length: 1, colour: '#b7b7b7', snap: true },
        trashcan: true,
        zoom: { controls: true, wheel: true, startScale: 0.9, maxScale: 2.0, minScale: 0.4 },
        move: { scrollbars: true, drag: true, wheel: true },
        sound: true
      });

      // Apply design enhancements (gradients + selection fix)
      addGradientDefs();           // Add gradient definitions for blocks
      killBlueSelection();         // Remove the default blue selection glow

      // Call this function to set up the listener
      setupGradientAndShadowOnBlocks();

      // Custom sound logic from Code A
      const audio = workspace.getAudioManager();
      audio.SOUNDS_ = {};

      audio.load(["./assets/blockly/sounds/block_merge.mpeg"], "click");
      audio.load(["./assets/blockly/sounds/cancel.mp3"], "delete");
      audio.load(["./assets/blockly/sounds/block_merge.mpeg"], "dragstart");
      audio.load(["./assets/blockly/sounds/block_merge.mpeg"], "dragend");
      audio.load(["./assets/blockly/sounds/error.mp3"], "error");
      audio.load(["./assets/blockly/sounds/disconnect.mp3"], "disconnect");

      // DRAG START
      // workspace.addChangeListener((ev) => {
      //   if (ev.type === Blockly.Events.BLOCK_DRAG && ev.isStart) {
      //     audio.play("dragstart");
      //   }
      // });

      // DRAG END
      // workspace.addChangeListener((ev) => {
      //   if (ev.type === Blockly.Events.BLOCK_DRAG && ev.isEnd) {
      //     audio.play("dragend");
      //   }
      // });

      // BLOCK SNAP / MOVE
      workspace.addChangeListener((ev) => {
        if (ev.type === Blockly.Events.BLOCK_MOVE && ev.isStart) {
          audio.play("click");
        }
      });

      // BLOCK DELETE
      workspace.addChangeListener((ev) => {
        if (ev.type === Blockly.Events.BLOCK_DELETE) {
          audio.play("delete");
        }
      });

      // INVALID CONNECTION (error sound)
      Blockly.Connection.prototype.highlightForError = function () {
        audio.play("error");
      };

      // Python output
      const pyOut = document.getElementById('pyOut');

      // runs whenever blocks change â€“ just for on-screen preview
      function updateCode() {
        const code = Blockly.Python.workspaceToCode(workspace);
        pyOut.textContent = code || '# (no blocks yet)';

        // Optional live preview message (not used for upload)
        try {
          window.ReactNativeWebView?.postMessage(
            JSON.stringify({ type: 'py_preview', code })
          );
        } catch (e) { }
      }

      workspace.addChangeListener(updateCode);
      updateCode();

      // ========== RUN / UPLOAD BUTTON ==========
      document.getElementById('btnRun').onclick = async () => {
        const code = Blockly.Python.workspaceToCode(workspace);

        // 1) Desktop: if Web Serial is available and port is open â†’ send ONLY "start()"
        if (window.navigator && "serial" in window.navigator && stm32Port && stm32Writer) {
          await sendCommandToStm32(code);
          return;
        }

        // 2) Mobile app (React Native WebView) â†’ send full python as before
        if (window.ReactNativeWebView && window.ReactNativeWebView.postMessage) {
          const payload = {
            type: "python_upload",
            code: code,
            entry_function: "main",
          };
          window.ReactNativeWebView.postMessage(JSON.stringify(payload));
          alert("Code sent to mobile app (no USB yet).");
          return;
        }

        // 3) Fallback: normal browser (no Web Serial, no RN) â†’ copy to clipboard
        alert("Python copied to clipboard (no STM32 connection).");
        navigator.clipboard?.writeText(code);
      };


      document.getElementById('btnSave').onclick = () => {
        const xml = Blockly.Xml.domToPrettyText(Blockly.Xml.workspaceToDom(workspace));
        const a = document.createElement('a');
        a.href = URL.createObjectURL(new Blob([xml], { type: 'text/xml' }));
        a.download = 'program.xml';
        a.click();
        URL.revokeObjectURL(a.href);
      };

      document.getElementById('btnLoad').onclick = async () => {
        const [f] = await (window.showOpenFilePicker
          ? await showOpenFilePicker({
            types: [{ description: 'XML', accept: { 'text/xml': ['.xml'] } }]
          }).catch(() => [])
          : []);
        let text = '';
        if (f) {
          text = await (await f.getFile()).text();
        } else {
          const inp = document.createElement('input');
          inp.type = 'file';
          inp.accept = '.xml,text/xml';
          inp.onchange = async e => {
            const file = e.target.files[0];
            const t = await file.text();
            loadXml(t);
          };
          inp.click();
          return;
        }
        loadXml(text);
      };

      function loadXml(text) {
        if (!text) return;
        workspace.clear();
        Blockly.Xml.domToWorkspace(Blockly.utils.xml.textToDom(text), workspace);
      }

      document.getElementById('btnClear').onclick = () => {
        workspace.clear();
        updateCode();
      };


      const demo = `
<xml xmlns="https://developers.google.com/blockly/xml">
  <block type="start" x="40" y="40">
    <field name="NAME">when Start Button clicked</field>
  </block>
</xml>`;
      Blockly.Xml.domToWorkspace(Blockly.utils.xml.textToDom(demo), workspace);
    }

    window.addEventListener('load', start);
    </script> 
  </body>

</html>